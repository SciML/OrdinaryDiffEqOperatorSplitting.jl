var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"S. Lie. Theorie der Transformationsgruppen I. Mathematische Annalen 16, 441–528 (1880).\n\n\n\nH. F. Trotter. On the Product of Semi-Groups of Operators. Proceedings of the American Mathematical Society 10, 545–551 (1959).\n\n\n\nS. K. Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. Matematicheskii Sbornik 89, 271–306 (1959).\n\n\n\n","category":"page"},{"location":"topics/time-integration/#theory_operator-splitting","page":"Theory Manual","title":"Operator Splitting Theory","text":"","category":"section"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"For operator splitting procedures we assume that we have some time-dependent problem with initial condition u_0 = u(t_0) and an operator F describing the right hand side. We assume that F can be additively split into N suboperators F_i. This can be formally written as","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"d_t u(t) = F(u(t) p t) = F_1(u(t) p t) +  + F_N(u(t) p t)  ","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"We call t time the u(t) the state of the system. This way we can define subproblems","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"beginaligned\n    d_t u(t) = F_1(u(t) p t) \n              vdots \n    d_t u(t) = F_N(u(t) p t)\nendaligned","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"Now, the key idea of operator splitting methods is that solving the subproblems can be easier, and hopefully more efficient, than solving the full problem. Arguably the easiest algorithm to advance the solution from t_0 to some time point t_1  t_0 is the Lie-Trotter-Godunov operator splitting [1–3]. Here the subproblems are solved consecutively, where the solution of one subproblem is taken as the initial guess for the next subproblem, until we have  solved all subproblems. In this case we have constructed an approximation  for u(t_1).","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"More formally we can write the Lie-Trotter-Godunov scheme [1–3] as follows:","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"beginaligned\n    textSolve quad d_t u^1(t) = F_1(u^1(t) p t)   quad texton  t_0 t_1  textwith  u^1(t_0) = u_0 \n    textSolve quad d_t u^2(t) = F_2(u^2(t) p t)   quad texton  t_0 t_1  textwith  u^2(t_0) = u^1(t_1) \n              vdots   \n    textSolve quad d_t u^N(t) = F_N(u^N(t) p t)   quad texton  t_0 t_1  textwith  u^N(t_0) = u^N-1(t_1)\nendaligned","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"Such that we obtain the approximation u(t_1) approx u^N-1(t_1). The approximation is first order in time, as we will show in the next section.","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"Probably the most widely spread application for operator splitting schemes is the solution forreaction diffusion systems. These have the form","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"d_t u(t) = Lu + R(u)","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"where L is some linear operator, usually coming from the linaerization of diffusion opeartors and a nonlinear reaction part R which has some interesting locality properties. This locallity property usually tells us that the time evolution of R natually decouples into many small blocks. This way we only have to solve for the time evolution of a linear problem d_t u(t) = Lu and a set of many very small nonlinear problems d_t u(t) = R(u).","category":"page"},{"location":"topics/time-integration/#Analysis-of-Lie-Trotter-Godunov","page":"Theory Manual","title":"Analysis of Lie-Trotter-Godunov","text":"","category":"section"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"It should be noted that even if we solve all subproblems analytically, then operator splitting schemes themselves almost always come with their own approximation error, which is simply called the splitting error. For linear problems this error can vanish if all suboperators F_i commute, i.e. if F_j cdot F_i = F_i cdot F_j for all 1 leq ij leq N, which can be shown with the Baker-Campbell-Hausdorff formula. Let us investigate the convergence order for two bounded linear operators L_1 and L_2, i.e. on the following system of ODEs","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"d_t u = L_1 u + L_2 u  ","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"Here the exact solution u at time point t for some initial condition at t_0 = 0 is","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"u(t) = e^(L_1 + L_2)t u_0  ","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"while the solution for the Lie-Trotter-Godunov scheme is","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"tildeu(t) = e^L_1te^L_2t u_0  ","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"The local truncation error can be written as","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"epsilon(t) = e^L_1te^L_2t - e^(L_1 + L_2)t  u_0","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"if we now replace the exponentials with their definitions we obtain for the first norm","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"beginaligned\n(I + tL_1 + frach^22L_1^2 + )(I + tL_2 + frach^22L_2^2 + ) - (I + t(L_1 + L_2) + frach^22(L_1+L_2)^2 + )\n= frach^22 (L_1 L_2 - L_2 L_1) +   leq frach^22  (L_1 L_2 - L_2 L_1)  + O(h^3)\nendaligned","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"This shows that the local truncation error is O(h^2) and hence the scheme is first order accurate.","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"Showing stability is also straight forward. We assumed that L_1 and L_2 are bounded, so we obtain for all time points t  t and all repeated subdivisions n in mathbbN the following bound","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"(e^L_1fractne^L_2fractn)^n\nleq e^L_1fractne^L_2fractn^n\nleq e^L_1fractn^n e^L_2fractn^n\nleq e^L_1t e^L_2t\nleq e^L_1t e^L_2t\nleq C  infty","category":"page"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"which implies stability of the scheme.","category":"page"},{"location":"topics/time-integration/#References","page":"Theory Manual","title":"References","text":"","category":"section"},{"location":"topics/time-integration/","page":"Theory Manual","title":"Theory Manual","text":"S. Lie. Theorie der Transformationsgruppen I. Mathematische Annalen 16, 441–528 (1880).\n\n\n\nH. F. Trotter. On the Product of Semi-Groups of Operators. Proceedings of the American Mathematical Society 10, 545–551 (1959).\n\n\n\nS. K. Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. Matematicheskii Sbornik 89, 271–306 (1959).\n\n\n\n","category":"page"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#Synchronizers-API","page":"Developer documentation","title":"Synchronizers API","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"A key part of operator splitting algorithms in the synchronization logic. Parameters of one subproblem might need to be kept in sync with the solution of other subproblems and vice versa. To handle this efficiently OrdinaryDiffEqOperatorSplitting.jl provides a small set of utils.","category":"page"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.NoExternalSynchronization","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.NoExternalSynchronization","text":"NoExternalSynchronization()\n\nIndicator that no synchronization between parameters and solution vectors is necessary.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!","text":" forward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DiffEqBase.DEIntegrator, solution_indices, sync)\n\nThis function is responsible to copy the solution and parameters of the outer integrator with the information given into the inner integrator. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!","text":" forward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DiffEqBase.DEIntegrator, solution_indices, sync)\n\nThis function is responsible to copy the solution of the inner integrator back into outer integrator. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.need_sync","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.need_sync","text":"need_sync(a, b)\n\nThis function determines whether it is necessary to synchronize two objects with any solution information. A possible reason when no syncronization is necessary might be that the vectors alias each other in memory.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.sync_vectors!","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.sync_vectors!","text":"sync_vectors!(a, b)\n\nCopies the information in object b into object a, if syncronization is necessary.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#Adding-Synchronizers","page":"Developer documentation","title":"Adding Synchronizers","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"warning: Warning\nThe API is not stable yet and subject to breaking changes.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"You need to provide dispatches for","category":"page"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!-devdocs-index","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!","text":" forward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DiffEqBase.DEIntegrator, solution_indices, sync)\n\nThis function is responsible to copy the solution and parameters of the outer integrator with the information given into the inner integrator. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!-devdocs-index","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!","text":" forward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DiffEqBase.DEIntegrator, solution_indices, sync)\n\nThis function is responsible to copy the solution of the inner integrator back into outer integrator. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"with your custom synchronizer object and add it to the split function construction as follows:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"f1, f2            = generate_individual_functions() # assuming 3 unknowns each\ni1, i2            = generate_solution_indices()     # e.g. ([1,2,3], Int[])\nsynchronizer_tree = generate_my_synchronizer_tree() # e.g. (MySyncronizer([1,2,3]), NoExternalSynchronization())\nf                 = GenericSplitFunction((f1,f2), (i1,i2), synchronizer_tree)\nu0                = [-1.0, 1.0, 0.0]\ntspan             = (0.0, 1.0)\nprob              = OperatorSplittingProblem(f, u0, tspan)","category":"page"},{"location":"devdocs/#Adding-Solvers","page":"Developer documentation","title":"Adding Solvers","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"warning: Warning\nThe API is not stable yet and subject to breaking changes.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"To add a new solver just define two new structs, one for the algorithm description and one for the algorithm cache and dispatch internal functions, as follows:","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"using SciMLBase, OrdinaryDiffEqOperatorSplitting\nstruct MySimpleFirstOrderAlgorithm{InnerAlgorithmTypes} <: OrdinaryDiffEqOperatorSplitting.AbstractOperatorSplittingAlgorithm\n    inner_algs::InnerAlgorithmTypes # Tuple of solver for the problem sequence\nend\n\nstruct MySimpleFirstOrderCache{uType, uprevType, iiType} <: OrdinaryDiffEqOperatorSplitting.AbstractOperatorSplittingCache\n    u::uType\n    uprev::uprevType\n    inner_caches::iiType\nend\n\nfunction OrdinaryDiffEqOperatorSplitting.init_cache(f::GenericSplitFunction, alg::MySimpleFirstOrderAlgorithm;\n    uprev::AbstractArray, u::AbstractVector,\n    inner_caches,\n    alias_uprev = true,\n    alias_u     = false,\n)\n    @assert length(inner_caches) == 2\n    _uprev = alias_uprev ? uprev : SciMLBase.recursivecopy(uprev)\n    _u     = alias_u     ? u     : SciMLBase.recursivecopy(u)\n    return MySimpleFirstOrderAlgorithmCache(_u, _uprev, inner_caches)\nend\n\n@inline function OrdinaryDiffEqOperatorSplitting.advance_solution_to!(outer_integrator::OperatorSplittingIntegrator, subintegrators::Tuple, solution_indices::Tuple, synchronizers::Tuple, cache::MySimpleFirstOrderAlgorithmCache, tnext)\n    # We assume that the integrators are already synced\n    @unpack inner_caches = cache\n\n    # Advance first subproblem\n    OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!(outer_integrator, subintegrators[1], solution_indices[1], synchronizers[1])\n    OrdinaryDiffEqOperatorSplitting.advance_solution_to!(outer_integrator, subintegrators[1], solution_indices[1], synchronizers[1], inner_caches[1], tnext)\n    if subintegrators[1].sol.retcode ∉ (SciMLBase.ReturnCode.Default, SciMLBase.ReturnCode.Success)\n        return\n    end\n    OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!(outer_integrator, subintegrators[1], solution_indices[1])\n\n    # Advance second subproblem\n    OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!(outer_integrator, subintegrators[2], solution_indices[2], synchronizers[2])\n    OrdinaryDiffEqOperatorSplitting.advance_solution_to!(outer_integrator, subintegrators[2], solution_indices[2], synchronizers[2], inner_caches[2], tnext)\n    if subintegrators[2].sol.retcode ∉ (SciMLBase.ReturnCode.Default, SciMLBase.ReturnCode.Success)\n        return\n    end\n    OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!(outer_integrator, subintegrators[2], solution_indices[2])\n\n    # Done :)\nend ","category":"page"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Minimal-Example","page":"Usage","title":"Minimal Example","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"For example, we can solve a simple split problem using the Euler() algorithm for each subproblem with the LieTrotterGodunov algorithm, by defining a problem tree and an analogue solver tree via tuples:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEqLowOrderRK, OrdinaryDiffEqOperatorSplitting\n# This is the true, full ODE.\nfunction ode_true(du, u, p, t)\n    du   .-= 0.1u\n    du[1] -= 0.01u[3]\n    du[3] -= 0.01u[1]\nend\n\n# This is the first operator of the ODE.\nfunction ode1(du, u, p, t)\n    @. du = -0.1u\nend\nf1 = ODEFunction(ode1)\nf1dofs = [1,2,3]\n\n# This is the second operator of the ODE.\nfunction ode2(du, u, p, t)\n    du[1] = -0.01u[2]\n    du[2] = -0.01u[1]\nend\nf2 = ODEFunction(ode2)\nf2dofs = [1,3]\n\n# This defines the split of the ODE.\nf = GenericSplitFunction((f1, f2), (f1dofs, f2dofs))\n\n# Next we can define the split problem.\nu0 = [-1.0, 1.0, 0.0]\ntspan = (0.0, 1.0)\nprob = OperatorSplittingProblem(f, u0, tspan)\n\n# And the time integration algorithm.\nalg = LieTrotterGodunov(\n    (Euler(), Euler())\n)\n\n# Right now OrdinaryDiffEqOperatorSplitting.jl does not implement the SciML solution interface,\n# but we can only intermediate solutions via the iterator interface.\nintegrator = init(prob, alg, dt=0.1)\nfor (u, t) in TimeChoiceIterator(integrator, 0.0:0.5:1.0)\n    @show t, u\nend","category":"page"},{"location":"api-reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api-reference/#Problems","page":"API Reference","title":"Problems","text":"","category":"section"},{"location":"api-reference/#OrdinaryDiffEqOperatorSplitting.OperatorSplittingProblem","page":"API Reference","title":"OrdinaryDiffEqOperatorSplitting.OperatorSplittingProblem","text":"OperatorSplittingProblem(f::AbstractOperatorSplitFunction, u0, tspan, p::Tuple)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api-reference/#OrdinaryDiffEqOperatorSplitting.GenericSplitFunction","page":"API Reference","title":"OrdinaryDiffEqOperatorSplitting.GenericSplitFunction","text":"GenericSplitFunction(functions::Tuple, solution_indices::Tuple)\nGenericSplitFunction(functions::Tuple, solution_indices::Tuple, syncronizers::Tuple)\n\nThis type of function describes a set of connected inner functions in mass-matrix form, as usually found in operator splitting procedures.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/#Solver","page":"API Reference","title":"Solver","text":"","category":"section"},{"location":"api-reference/#OrdinaryDiffEqOperatorSplitting.LieTrotterGodunov","page":"API Reference","title":"OrdinaryDiffEqOperatorSplitting.LieTrotterGodunov","text":"LieTrotterGodunov <: AbstractOperatorSplittingAlgorithm\n\nA first order sequential operator splitting algorithm attributed to [1–3].\n\n\n\n\n\n","category":"type"},{"location":"#OrdinaryDiffEqOperatorSplitting.jl","page":"Home","title":"OrdinaryDiffEqOperatorSplitting.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Toolbox to handle split formulations of a wide variety of ODE and DAE problems.","category":"page"}]
}
