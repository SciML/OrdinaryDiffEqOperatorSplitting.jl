var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"S. Lie. Theorie der Transformationsgruppen I. Mathematische Annalen 16, 441–528 (1880).\n\n\n\nH. F. Trotter. On the Product of Semi-Groups of Operators. Proceedings of the American Mathematical Society 10, 545–551 (1959).\n\n\n\nS. K. Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. Matematicheskii Sbornik 89, 271–306 (1959).\n\n\n\n","category":"section"},{"location":"topics/time-integration/#theory_operator-splitting","page":"Theory Manual","title":"Operator Splitting Theory","text":"For operator splitting procedures we assume that we have some time-dependent problem with initial condition u_0 = u(t_0) and an operator F describing the right hand side. We assume that F can be additively split into N suboperators F_i. This can be formally written as\n\nd_t u(t) = F(u(t) p t) = F_1(u(t) p t) +  + F_N(u(t) p t)  \n\nWe call t time and u(t) the state of the system. This way we can define subproblems\n\nbeginaligned\n    d_t u(t) = F_1(u(t) p t) \n              vdots \n    d_t u(t) = F_N(u(t) p t)\nendaligned\n\nNow, the key idea of operator splitting methods is that solving the subproblems can be easier, and hopefully more efficient, than solving the full problem. Arguably the easiest algorithm to advance the solution from t_0 to some time point t_1  t_0 is the Lie-Trotter-Godunov operator splitting [1–3]. Here the subproblems are solved consecutively, where the solution of one subproblem is taken as the initial guess for the next subproblem, until we have solved all subproblems. In this case we have constructed an approximation for u(t_1).\n\nMore formally we can write the Lie-Trotter-Godunov scheme [1–3] as follows:\n\nbeginaligned\n    textSolve quad d_t u^1(t) = F_1(u^1(t) p t)   quad texton  t_0 t_1  textwith  u^1(t_0) = u_0 \n    textSolve quad d_t u^2(t) = F_2(u^2(t) p t)   quad texton  t_0 t_1  textwith  u^2(t_0) = u^1(t_1) \n              vdots   \n    textSolve quad d_t u^N(t) = F_N(u^N(t) p t)   quad texton  t_0 t_1  textwith  u^N(t_0) = u^N-1(t_1)\nendaligned\n\nSuch that we obtain the approximation u(t_1) approx u^N-1(t_1). The approximation is first order in time, as we will show in the next section.\n\nProbably the most widely spread application for operator splitting schemes is the solution of reaction diffusion systems. These have the form\n\nd_t u(t) = Lu + R(u)\n\nwhere L is some linear operator, usually coming from the linearization of diffusion operators and a nonlinear reaction part R which has some interesting locality properties. This locality property usually tells us that the time evolution of R naturally decouples into many small blocks. This way we only have to solve for the time evolution of a linear problem d_t u(t) = Lu and a set of many very small nonlinear problems d_t u(t) = R(u).","category":"section"},{"location":"topics/time-integration/#Analysis-of-Lie-Trotter-Godunov","page":"Theory Manual","title":"Analysis of Lie-Trotter-Godunov","text":"It should be noted that even if we solve all subproblems analytically, then operator splitting schemes themselves almost always come with their own approximation error, which is simply called the splitting error. For linear problems this error can vanish if all suboperators F_i commute, i.e. if F_j cdot F_i = F_i cdot F_j for all 1 leq ij leq N, which can be shown with the Baker-Campbell-Hausdorff formula. Let us investigate the convergence order for two bounded linear operators L_1 and L_2, i.e. on the following system of ODEs\n\nd_t u = L_1 u + L_2 u  \n\nHere the exact solution u at time point t for some initial condition at t_0 = 0 is\n\nu(t) = e^(L_1 + L_2)t u_0  \n\nwhile the solution for the Lie-Trotter-Godunov scheme is\n\ntildeu(t) = e^L_1te^L_2t u_0  \n\nThe local truncation error can be written as\n\nepsilon(t) = e^L_1te^L_2t - e^(L_1 + L_2)t  u_0\n\nif we now replace the exponentials with their definitions we obtain for the first norm\n\nbeginaligned\n(I + tL_1 + frach^22L_1^2 + )(I + tL_2 + frach^22L_2^2 + ) - (I + t(L_1 + L_2) + frach^22(L_1+L_2)^2 + )\n= frach^22 (L_1 L_2 - L_2 L_1) +   leq frach^22  (L_1 L_2 - L_2 L_1)  + O(h^3)\nendaligned\n\nThis shows that the local truncation error is O(h^2) and hence the scheme is first order accurate.\n\nShowing stability is also straight forward. We assumed that L_1 and L_2 are bounded, so we obtain for all time points t  t and all repeated subdivisions n in mathbbN the following bound\n\n(e^L_1fractne^L_2fractn)^n\nleq e^L_1fractne^L_2fractn^n\nleq e^L_1fractn^n e^L_2fractn^n\nleq e^L_1t e^L_2t\nleq e^L_1t e^L_2t\nleq C  infty\n\nwhich implies stability of the scheme.","category":"section"},{"location":"topics/time-integration/#References","page":"Theory Manual","title":"References","text":"S. Lie. Theorie der Transformationsgruppen I. Mathematische Annalen 16, 441–528 (1880).\n\n\n\nH. F. Trotter. On the Product of Semi-Groups of Operators. Proceedings of the American Mathematical Society 10, 545–551 (1959).\n\n\n\nS. K. Godunov. A difference method for numerical calculation of discontinuous solutions of the equations of hydrodynamics. Matematicheskii Sbornik 89, 271–306 (1959).\n\n\n\n","category":"section"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/#Synchronizers-API","page":"Developer documentation","title":"Synchronizers API","text":"A key part of operator splitting algorithms is the synchronization logic. Parameters of one subproblem might need to be kept in sync with the solution of other subproblems and vice versa. To handle this efficiently OrdinaryDiffEqOperatorSplitting.jl provides a small set of utils.","category":"section"},{"location":"devdocs/#Adding-Synchronizers","page":"Developer documentation","title":"Adding Synchronizers","text":"warning: Warning\nThe API is not stable yet and subject to breaking changes.\n\nYou need to provide dispatches for\n\nwith your custom synchronizer object and add it to the split function construction as follows:\n\nf1, f2 = generate_individual_functions() # assuming 3 unknowns each\ni1, i2 = generate_solution_indices()     # e.g. ([1,2,3], Int[])\nsynchronizer_tree = generate_my_synchronizer_tree() # e.g. (MySynchronizer([1,2,3]), NoExternalSynchronization())\nf = GenericSplitFunction((f1, f2), (i1, i2), synchronizer_tree)\nu0 = [-1.0, 1.0, 0.0]\ntspan = (0.0, 1.0)\nprob = OperatorSplittingProblem(f, u0, tspan)","category":"section"},{"location":"devdocs/#Adding-Solvers","page":"Developer documentation","title":"Adding Solvers","text":"warning: Warning\nThe API is not stable yet and subject to breaking changes.\n\nTo add a new solver just define two new structs, one for the algorithm description and one for the algorithm cache and dispatch internal functions, as follows:\n\nusing SciMLBase, OrdinaryDiffEqOperatorSplitting\nstruct MySimpleFirstOrderAlgorithm{InnerAlgorithmTypes} <:\n       OrdinaryDiffEqOperatorSplitting.AbstractOperatorSplittingAlgorithm\n    inner_algs::InnerAlgorithmTypes # Tuple of solver for the problem sequence\nend\n\nstruct MySimpleFirstOrderCache{uType, uprevType, iiType} <:\n       OrdinaryDiffEqOperatorSplitting.AbstractOperatorSplittingCache\n    u::uType\n    uprev::uprevType\n    inner_caches::iiType\nend\n\nfunction OrdinaryDiffEqOperatorSplitting.init_cache(\n        f::GenericSplitFunction, alg::MySimpleFirstOrderAlgorithm;\n        uprev::AbstractArray, u::AbstractVector,\n        inner_caches,\n        alias_uprev = true,\n        alias_u = false\n)\n    @assert length(inner_caches) == 2\n    _uprev = alias_uprev ? uprev : SciMLBase.recursivecopy(uprev)\n    _u = alias_u ? u : SciMLBase.recursivecopy(u)\n    return MySimpleFirstOrderAlgorithmCache(_u, _uprev, inner_caches)\nend\n\n@inline function OrdinaryDiffEqOperatorSplitting.advance_solution_to!(\n        outer_integrator::OperatorSplittingIntegrator, subintegrators::Tuple,\n        solution_indices::Tuple, synchronizers::Tuple,\n        cache::MySimpleFirstOrderAlgorithmCache, tnext)\n    # We assume that the integrators are already synced\n    @unpack inner_caches = cache\n\n    # Advance first subproblem\n    OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!(\n        outer_integrator, subintegrators[1], solution_indices[1], synchronizers[1])\n    OrdinaryDiffEqOperatorSplitting.advance_solution_to!(\n        outer_integrator, subintegrators[1], solution_indices[1],\n        synchronizers[1], inner_caches[1], tnext)\n    if subintegrators[1].sol.retcode ∉\n       (SciMLBase.ReturnCode.Default, SciMLBase.ReturnCode.Success)\n        return\n    end\n    OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!(\n        outer_integrator, subintegrators[1], solution_indices[1], synchronizers[1])\n\n    # Advance second subproblem\n    OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!(\n        outer_integrator, subintegrators[2], solution_indices[2], synchronizers[2])\n    OrdinaryDiffEqOperatorSplitting.advance_solution_to!(\n        outer_integrator, subintegrators[2], solution_indices[2],\n        synchronizers[2], inner_caches[2], tnext)\n    if subintegrators[2].sol.retcode ∉\n       (SciMLBase.ReturnCode.Default, SciMLBase.ReturnCode.Success)\n        return\n    end\n    OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!(\n        outer_integrator, subintegrators[2], solution_indices[2], synchronizers[2])\n\n    # Done :)\nend","category":"section"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.NoExternalSynchronization","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.NoExternalSynchronization","text":"NoExternalSynchronization()\n\nIndicator that no synchronization between parameters and solution vectors is necessary.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!","text":" forward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DEIntegrator, solution_indices, sync)\n\nThis function is responsible of copying the solution and parameters of the outer integrator and the synchronized subintegrators with the information given into the inner integrator. If the inner integrator is synchronized with other inner integrators using sync, the function forward_sync_external! shall be dispatched for sync. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!","text":"backward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DEIntegrator, solution_indices, sync)\n\nThis function is responsible of copying the solution of the inner integrator back into outer integrator and the synchronized subintegrators. If the inner integrator is synchronized with other inner integrators using sync, the function backward_sync_external! shall be dispatched for sync. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.need_sync","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.need_sync","text":"need_sync(a, b)\n\nThis function determines whether it is necessary to synchronize two objects with any solution information. A possible reason when no synchronization is necessary might be that the vectors alias each other in memory.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.sync_vectors!","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.sync_vectors!","text":"sync_vectors!(a, b)\n\nCopies the information in object b into object a, if synchronization is necessary.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!-devdocs-index","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.forward_sync_subintegrator!","text":" forward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DEIntegrator, solution_indices, sync)\n\nThis function is responsible of copying the solution and parameters of the outer integrator and the synchronized subintegrators with the information given into the inner integrator. If the inner integrator is synchronized with other inner integrators using sync, the function forward_sync_external! shall be dispatched for sync. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!-devdocs-index","page":"Developer documentation","title":"OrdinaryDiffEqOperatorSplitting.backward_sync_subintegrator!","text":"backward_sync_subintegrator!(outer_integrator::OperatorSplittingIntegrator, inner_integrator::DEIntegrator, solution_indices, sync)\n\nThis function is responsible of copying the solution of the inner integrator back into outer integrator and the synchronized subintegrators. If the inner integrator is synchronized with other inner integrators using sync, the function backward_sync_external! shall be dispatched for sync. The sync object is passed from the outside and is the main entry point to dispatch custom types on for parameter synchronization. The solution_indices are global indices in the outer integrators solution vectors.\n\n\n\n\n\n","category":"function"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/#Minimal-Example","page":"Usage","title":"Minimal Example","text":"For example, we can solve a simple split problem using the Euler() algorithm for each subproblem with the LieTrotterGodunov algorithm, by defining a problem tree and an analogue solver tree via tuples:\n\nusing OrdinaryDiffEqLowOrderRK, OrdinaryDiffEqOperatorSplitting\n# This is the true, full ODE.\nfunction ode_true(du, u, p, t)\n    du .-= 0.1u\n    du[1] -= 0.01u[3]\n    du[3] -= 0.01u[1]\nend\n\n# This is the first operator of the ODE.\nfunction ode1(du, u, p, t)\n    @. du = -0.1u\nend\nf1 = ODEFunction(ode1)\nf1dofs = [1, 2, 3]\n\n# This is the second operator of the ODE.\nfunction ode2(du, u, p, t)\n    du[1] = -0.01u[2]\n    du[2] = -0.01u[1]\nend\nf2 = ODEFunction(ode2)\nf2dofs = [1, 3]\n\n# This defines the split of the ODE.\nf = GenericSplitFunction((f1, f2), (f1dofs, f2dofs))\n\n# Next we can define the split problem.\nu0 = [-1.0, 1.0, 0.0]\ntspan = (0.0, 1.0)\nprob = OperatorSplittingProblem(f, u0, tspan)\n\n# And the time integration algorithm.\nalg = LieTrotterGodunov(\n    (Euler(), Euler())\n)\n\n# Right now OrdinaryDiffEqOperatorSplitting.jl does not implement the SciML solution interface,\n# but we can obtain intermediate solutions via the iterator interface.\nintegrator = init(prob, alg, dt = 0.1)\nfor (u, t) in TimeChoiceIterator(integrator, 0.0:0.5:1.0)\n    @show t, u\nend","category":"section"},{"location":"api-reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api-reference/#Problems","page":"API Reference","title":"Problems","text":"","category":"section"},{"location":"api-reference/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"api-reference/#Solver","page":"API Reference","title":"Solver","text":"","category":"section"},{"location":"api-reference/#OrdinaryDiffEqOperatorSplitting.OperatorSplittingProblem","page":"API Reference","title":"OrdinaryDiffEqOperatorSplitting.OperatorSplittingProblem","text":"OperatorSplittingProblem(f::AbstractOperatorSplitFunction, u0, tspan, p::Tuple)\n\n\n\n\n\n","category":"type"},{"location":"api-reference/#OrdinaryDiffEqOperatorSplitting.GenericSplitFunction","page":"API Reference","title":"OrdinaryDiffEqOperatorSplitting.GenericSplitFunction","text":"GenericSplitFunction(functions::Tuple, solution_indices::Tuple)\nGenericSplitFunction(functions::Tuple, solution_indices::Tuple, synchronizers::Tuple)\n\nThis type of function describes a set of connected inner functions in mass-matrix form, as usually found in operator splitting procedures.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/#OrdinaryDiffEqOperatorSplitting.LieTrotterGodunov","page":"API Reference","title":"OrdinaryDiffEqOperatorSplitting.LieTrotterGodunov","text":"LieTrotterGodunov <: AbstractOperatorSplittingAlgorithm\n\nA first order sequential operator splitting algorithm attributed to [1–3].\n\n\n\n\n\n","category":"type"},{"location":"#OrdinaryDiffEqOperatorSplitting.jl","page":"Home","title":"OrdinaryDiffEqOperatorSplitting.jl","text":"Toolbox to handle split formulations of a wide variety of ODE and DAE problems.","category":"section"}]
}
